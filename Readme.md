# Хэш-таблица 


Данный репозиторий содержит реализацию хэш таблицы с открытой адресацией и двойным хэшированием в качестве способа разрешения коллизий.

---

## Оглавление
1. [Введение](#Введение)
2. [Хэш-таблица](#Хэш-таблица)
3. [Хэш-функция](#Хэш-функция)
4. [Разрешение коллизий](#Разрешение-коллизий)
5. [Изменение размера таблицы](#Изменение-размера-таблицы)
6. [Реализация операций](#Реализация-операций)

***

## **Введение**
***
### ***Хэширование***

`Хэширование` - техника быстрой записи и  быстрого доступа к информации. Используется для поиска за оптимальное время, полезна при реализации символьных таблиц. 



### ***Быстродействие***
|операция\случай| Средний случай | Худший случай |
|:-------------:|:--------------:|:-------------:|
|Поиск|O(1)|O(n)|
|Вставка|O(1)|O(n)|
|Удаление|O(1)|O(n)|


### ***Составляющие хэширования***

Под хэшированием будем понимать совокупность 4 основных компонентов:
1. Хэш-таблица
2. Хэш-функция
3. Коллизии
4. Техники разрешения коллизий



### ***Основные операции для хэш-таблиц***
+ Создание хэш-таблицы
+ Удаление таблицы
+ Вставка нового ключа  в таблицу 
+ Поиск в таблице по ключу
+ Удаление ключа из таблицы

### ***Требования к хэш функциям***
Хэш-функция отображает множество ключей на множество индексов.

Хэш-функция должна
+ минимизировать число коллизий
+ быть простой и вычисляться быстро
+ равномерно распределять ключи по таблице
+ использовать всю информацию, содержащуюся в ключе
+ иметь достаточно высокий коэффициент заполнения для данного набора ключей

### ***Коллизии и разрешение коллизий***
`Коллизия` - ситуация, при которой две записи должны быть сохранены в одной локации. (два разных ключа отобразились в один и тот же слот).

`Разрешение коллизий`- процесс поиска альтернативной не занятой локации.
Часто встречающиеся техники разрешения:
+ Метод цепочек (реализован как массив связных списков)
+ Открытая адресация (реализована в виде массива)
    + с линейным поиском
	+ с квадратичным поиском
	+ с двойным хэшированием

### ***Используемые термины***
+ `Запись` (`элемент`) - пара ключ-значение или  просто значение, в которое отображается ключ.
+ `Слот` - пустая или занятая ячейка хэш-таблицы
+ `Индекс` - значение, возвращаемое хэш-функцией. Соответсвует порядковому номеру слота.

![Отображение множества ключей на слоты хэш-таблицы][hash_table]

[hash_table]: Hash_table.bmp



[ к оглавлению ](#Оглавление)

***


## **Хэш-таблица**
***
Записи, т.е. пары ключ-значение, будем сохранять в структуре `ht_item` :

```c
typedef struct ht_item {
	char* key;
	char* value;
} ht_item;
```
Сама таблица будет содержать массив указателей на записи(на ht_item), а также дополнительную информацию о своём размере и количестве хранящихся записей:


```c
typedef struct {
	int base_size; /*используется при изменении размера таблицы*/
	int size;
	int count;
	ht_item** items;
} ht_hash_table;
```

***Инициализация и освобождение памяти:***

```c
/*****************************************
 * Создание и инициализация пустой таблицы
 *****************************************/
ht_hash_table* ht_new() {
	return ht_new_sized(HT_INITIAL_BASE_SIZE);
}




/**********************
 * Удаление таблицы
 **********************/
void ht_del_hash_table(ht_hash_table* ht) {
    for (int i = 0; i < ht->size; i++) {
        ht_item* item = ht->items[i];
        if (item != NULL) {
            ht_del_item(item);
        }
    }
    free(ht->items);
    free(ht);
}




/*******************************************
 * Создание и инициализация нового элемента
 *******************************************/
static ht_item* ht_new_item(const char* k, const char* v) {
	ht_item* i = (ht_item*)malloc(sizeof(ht_item));
	i->key = _strdup(k);
	i->value = _strdup(v);
	return i;
}




/*************************************
 * Удаление элемента(записи) ht_item i
 ****************************************/
static void ht_del_item(ht_item* i) {
	free(i->key);
	free(i->value);
	free(i);
}


```

[ к оглавлению ](#Оглавление)
***
## **Хэш-функция**
***
Хэш-функция используется для отображения множества ключей на слоты хэш-таблицы. Ключи в контексте этой работы представляют собой ASCII строку.
Таким образом хэш функция должна:
+ получить строку на входе и вернуть число (`индекс`) в диапазоне от `0` до `m`, где `m` - максимальный размер таблицы (максимальное количество слотов)
+ обеспечить равномерное отображение ключей на индексы (равномерное распределение записей по слотам) для набора входных данных. Если распределение будет неравномерным, то увеличится количество коллизий, что снизит скорость работы с таблицей.


Предлагаемый алгоритм работы хэш функции:
```
function hash(string, a, num_buckets):
    hash = 0
    string_len = length(string)
    for i = 0, 1, ..., string_len:
        hash += (a ** (string_len - (i+1))) * char_code(string[i])
    hash = hash % num_buckets
    return hash
```

Основные этапы работы алгоритма:
1. Отобразить строку в большое целое число
2. Получить `индекс` в заданном диапазоне, разделив по модулю полученное на предыдущем этапе число на число слотов в таблице. `Индекс` в данном случае соответсвует номеру слота, в который будет помещена запись (ключ-значение).

а - простое число, превосходящее размер используемого алфавита. В данной работе используются ASCII строки, размер алфавита для которых равен 128, в дальнейшем выберем а>128. 

`char_code(string[i])` - функция, возвращающая целое число, соответсвующее символу. Вместо функции будем использовать ASCII код символа.

Пример работы алгоритма:

```
hash("cat", 151, 53)

hash = (151**2 * 99 + 151**1 * 97 + 151**0 * 116) % 53
hash = (2257299 + 14647 + 116) % 53
hash = (2272062) % 53
hash = 5
```


Реализация алгоритма работы хэш-функции:

```c
static int ht_generic_hash(const char* s, const int a, const int m) {
	long hash = 0;
	const int len_s = strlen(s);
	for (int i = 0; i < len_s; i++) {
		/* посимвольное отображение в целое число */
		hash += (unsigned long)pow(a, len_s - (i + 1)) * s[i];
	}
	hash = hash % m;
	return (int)hash;
}
```
[ к оглавлению ](#Оглавление)

***
## **Разрешение коллизий**
***
В качестве техники разрешения коллизий выбрана `открытая адресация с двойным хэшированием`.

При использовании метода `открытой адресации` все элементы (пары ключ-значение хранятся непосредственно в  хэш-таблице, т.е каждый слот содержит либо запись(элемент), либо значение NIL.

`Двойное хэширование` использует функцию вида: 
`h(k,i) = (h1(k) + i*h2(k)) mod m` , где h1 и h2 - вспомогательные хэш-функции.

При поиске альтернативного слота у нас должна быть возможность охватить все слоты таблицы, поэтому значение h2(k) должно быть взаимно простым с размером хэш-таблицы *`m`*. Поэтому в качестве `m` мы используем простое число, а функцию h2(k) построим таким образом, чтобы она всегда возвращала натуральное число меньше *`m`* и больше 0 (а `ты` считаешь 0 натуральным? Почему?).

```c
static int ht_hash(const char* s, const int num_buckets, const int attempt) {
	const int hash_a = ht_generic_hash(s, HT_PRIME_1, num_buckets);
	const int hash_b = ht_generic_hash(s, HT_PRIME_2, num_buckets-1);
	return (hash_a + (attempt * (hash_b + 1))) % num_buckets;
}
```
[ к оглавлению ](#Оглавление)

***
## **Изменение размера таблицы**
***
По мере увеличения числа записей будет увеличиваться `коэффициент заполнения таблицы` (отношение числа записей к числу слотов).
После превышения определенного значения коэффициента производительность операций вставки начнёт падать, количество коллизий увеличиваться.  Возможна также обратная ситуация - под таблицу выделено много памяти, но после удаления записей большая часть слотов пустует. В подобных ситуациях необходимо изменить размер таблицы.

Мы будем изменять размер, если `коэффициент заполнения таблицы`
(КЗТ) :
+ КЗТ > 0.7
+ КЗТ < 0.1

При изменении размера мы создаём новую таблицу приблизительно в 2 раза отличающуюся по размеру от текущей и заново заполняем её имеющимися записями (которые не были удалены, т.е. не являются пустыми)

Текущий размер сохраняется в поле `base_size`.
Затем  ищется ближайшее простое число большее удвоенного `base_size` при увеличении размера таблицы и меньшее половины `base_size` при уменьшении.
При поиске ближайшего простого числа будем использовать метод перебора.
функция для поиска простых чисел объявлена и реализована в файлах
Prime.h и Prime.cpp.
```c
// Prime.h
int is_prime(const int x);
int next_prime(int x);
```
```c
//Prime.cpp
/****************************************
 * Показывает является ли х простым
 *
 * возвращает:
 *   1  - простое
 *   0  - не является простым
 *   -1 -  x < 2
 ****************************************/
int is_prime(const int x) {
	if (x < 2) { return -1; }
	if (x < 4) { return 1; }
	if ((x % 2) == 0) { return 0; }
	for (int i = 3; i <= floor(sqrt((double)x)); i += 2) {
		if ((x % i) == 0) {
			return 0;
		}
	}
	return 1;
}


/****************************************************************
 * Возвращает ближайшее простое после х или х, если  х - простое
 ***************************************************************/
int next_prime(int x) {
	while (is_prime(x) != 1) {
		x++;
	}
	return x;
}
```

```c
/********************************************
 * Создаёт и инициализирует новую хэш-таблицу
 ***********************************************/
static ht_hash_table* ht_new_sized(const int base_size) {
	ht_hash_table* ht = (ht_hash_table*)malloc(sizeof(ht_hash_table));
	ht->base_size = base_size;

//  определяем ближайшее простое 
	ht->size = next_prime(base_size);

	ht->count = 0;
// создаём массив слотов, хранящих пустые записи, инициализированные нулями
	ht->items = (ht_item**)calloc((size_t)ht->size, sizeof(ht_item*));
	return ht;
}
```

```c
/****************************
 * Изменяет размер хэш-таблицы
 ******************************/
static void ht_resize(ht_hash_table* ht, const int new_base_size) {
	// минимальный размер таблицы ограничен
	if (new_base_size < HT_INITIAL_BASE_SIZE) {	
		return;	 
	}

	// Создаём и заполняем новую таблицу
	ht_hash_table* new_ht = ht_new_sized(new_base_size);
	for (int i = 0; i < ht->size; i++) {
		ht_item* item = ht->items[i];
		if (item != NULL && item != &HT_DELETED_ITEM) {
			ht_insert(new_ht, item->key, item->value);
		}
	}

	// Меняем местами содержимое полей новой и текущей структур
	ht->base_size = new_ht->base_size;
	ht->count = new_ht->count;

	const int tmp_size = ht->size;
	ht->size = new_ht->size;
	new_ht->size = tmp_size;

	ht_item** tmp_items = ht->items;
	ht->items = new_ht->items;
	new_ht->items = tmp_items;

	// очищаем память, содержащую прежние значения, на которые теперь указывает созданная структура
	ht_del_hash_table(new_ht);
}
```

```c
/************************************
 * Функции меняющие размер таблицы
 *************************************/

static void ht_resize_up(ht_hash_table* ht) {
	const int new_size = ht->base_size * 2;
	ht_resize(ht, new_size);
}


static void ht_resize_down(ht_hash_table* ht) {
	const int new_size = ht->base_size / 2;
	ht_resize(ht, new_size);
}
```
[ к оглавлению ](#Оглавление)
***
## **Реализация операций**
***
При реализации операций  потребуется специальная запись:
```c
static ht_item HT_DELETED_ITEM = { NULL, NULL };
```

### ***Вставка***
Каждый ключ в таблице уникален, повторяющиеся ключи не допускаются. При попытке вставить новую пару ключ-значение по существующему в таблице ключу приведёт к перезаписи имеющегося элемента.
```c
/*********************************************
 * Вставка пары ключ : значение в слот таблицы
 **********************************************/
void ht_insert(ht_hash_table* ht, const char* key, const char* value) {
	// Изменить размер если КЗТ > 0.7
	const int load = ht->count * 100 / ht->size;
	if (load > 70) {
		ht_resize_up(ht);
	}

	// вспомогательный указатель на элемент 
	ht_item* item = ht_new_item(key, value);

	//вычисляем индекс
	int index = ht_hash(item->key, ht->size, 0);

	//устанавливаем ещё один вспомогательный указатель на слот с найденным индексом
	ht_item* cur_item = ht->items[index];
	int i = 1;

// Проходим по слотам таблицы, ища свободный  
// или перезаписываем значение по ключу(если ключ есть в таблице) и выходим 
	while (cur_item != NULL && cur_item != &HT_DELETED_ITEM) {
		if (strcmp(cur_item->key, key) == 0) {
			ht_del_item(cur_item);
			ht->items[index] = item;
			return;
		}
		index = ht_hash(item->key, ht->size, i);
		cur_item = ht->items[index];
		i++;
	}

	// теперь получен индекс пустого слота,
	// записываем элемент, увеличиваем счётчик занятых слотов
	ht->items[index] = item;
	ht->count++;
}
```

### ***Поиск***
```c
/********************************************************************
 * Возвращает значение по ключу, либо NULL, если ключа нет в таблице
 ********************************************************************/
char* ht_search(ht_hash_table* ht, const char* key) {
	int index = ht_hash(key, ht->size, 0);
	ht_item* item = ht->items[index];
	int i = 1;
	while (item != NULL) {
		if (item != &HT_DELETED_ITEM) {
			if (strcmp(item->key, key) == 0) {
				return item->value;
			}
		}
		index = ht_hash(key, ht->size, i);
		item = ht->items[index];
		i++;
	}
	return NULL;
}
```
### ***Удаление***
 Поскольку элемент мог участвовать при разрешении коллизий и входить в цепочку слотов, получаемых при двойном хэшировании, мы должны сохранить возможность найти элементы, следующие за удаляемым. Для этого указатель на удаляемый элемент заменяется на &HT_DELETED_ITEM= { NULL, NULL }.
```c
/******************************************************
 * Удаляет значение по ключу. Если ключа нет - выходим
 *******************************************************/
void ht_delete(ht_hash_table* ht, const char* key) {
	// Изменяем размер, если КЗТ < 0.1

	const int load = ht->count * 100 / ht->size;
	if (load < 10) {
		ht_resize_down(ht);
	}

	int index = ht_hash(key, ht->size, 0);
	ht_item* item = ht->items[index];
	int i = 1;
	while (item != NULL) {
    	if (item != &HT_DELETED_ITEM) {
            if (strcmp(item->key, key) == 0) {
                ht_del_item(item);
                ht->items[index] = &HT_DELETED_ITEM;
                ht->count--; 
                return;
            }
        }
        index = ht_hash(key, ht->size, i);
        item = ht->items[index];
        i++;
	}
}
```
